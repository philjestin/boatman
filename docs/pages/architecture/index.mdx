# Architecture Overview

The Boatman Ecosystem is composed of four modules that communicate through structured events and HTTP APIs.

## High-Level Architecture

```
┌──────────────────────────────────────────────────────────────────────┐
│                        Boatman Ecosystem                              │
│                                                                      │
│  ┌─────────────────────┐         ┌─────────────────────┐            │
│  │   BoatmanMode CLI   │         │   Boatman Desktop   │            │
│  │   (cli/)            │ ──────▶ │   (desktop/)        │            │
│  │                     │  JSON   │                     │            │
│  │  Go CLI + Library   │ Events  │  Wails (Go+React)   │            │
│  └─────────┬───────────┘         └──────────┬──────────┘            │
│            │                                │                        │
│            │  HTTP (optional)               │                        │
│            ▼                                │                        │
│  ┌─────────────────────────────┐            │                        │
│  │   Boatman Platform          │            │                        │
│  │   (platform/)               │            │                        │
│  │                             │            │                        │
│  │  • Shared Memory Service    │            │                        │
│  │  • Policy Engine            │            │                        │
│  │  • Cost Governance          │            │                        │
│  │  • Event Bus (NATS)         │            │                        │
│  │  • Web Dashboard            │            │                        │
│  │  • SQLite Storage           │            │                        │
│  └─────────────────────────────┘            │                        │
│                                              │                        │
│  ┌─────────────────────┐         ┌──────────▼──────────┐            │
│  │  External Services  │         │   MCP Servers       │            │
│  │  • Claude API       │         │   • Linear          │            │
│  │  • Linear API       │         │   • Datadog         │            │
│  │  • GitHub API       │         │   • Bugsnag         │            │
│  │  • Git / tmux       │         │   • Slack           │            │
│  └─────────────────────┘         └─────────────────────┘            │
│                                                                      │
│  ┌─────────────────────┐  ┌─────────────────────┐                   │
│  │  Harness (harness/) │  │   Shared (shared/)  │                   │
│  │  Model-agnostic     │  │   Common Go pkgs    │                   │
│  │  AI agent primitives│  └─────────────────────┘                   │
│  └─────────────────────┘                                             │
│                                                                      │
│  go.work ties all modules together for development                   │
└──────────────────────────────────────────────────────────────────────┘
```

---

## Design Principles

### Subprocess Integration
The Desktop app calls the CLI as a subprocess (`exec.Command`) rather than importing Go modules. This provides:
- Clean separation of concerns (UI vs engine)
- Independent versioning and releases
- BoatmanMode's `internal/` packages stay encapsulated
- CLI works standalone or through the GUI

### Event-Driven Communication
The CLI emits structured JSON events to stdout. The Desktop captures these events and updates the UI in real-time. This loose coupling means:
- CLI has no knowledge of the Desktop
- Desktop can handle any event-emitting process
- Events are easily consumed by other tools (CI, dashboards)

### Graceful Degradation
The Platform is an optional add-on. The CLI works standalone with full functionality; the Platform adds organizational features when available. The CLI uses a `TryConnect` pattern with a 3-second timeout — if the platform is unreachable, it continues in standalone mode.

### Go Workspace
The `go.work` file ties modules together for development while allowing independent `go.mod` files:

```go
go 1.24.1

use (
    ./cli
    ./desktop
    ./harness
    ./shared
    ./platform
)
```

### Agent Isolation
Each AI agent runs in its own context:
- Fresh agent per workflow step (no context bloat)
- Structured handoffs with token-aware compression
- Git worktree isolation for file changes
- tmux sessions for live observation

---

## Module Dependencies

```
cli/
  module: github.com/philjestin/boatmanmode
  deps: cobra, viper

desktop/
  module: boatman
  deps: wails/v2, google/uuid, pkg/browser

harness/
  module: github.com/philjestin/boatman-ecosystem/harness
  deps: (stdlib only)

platform/
  module: github.com/philjestin/boatman-ecosystem/platform
  deps: nats-server, nats.go, modernc.org/sqlite, harness, shared

shared/
  module: github.com/philjestin/boatman/shared
  deps: (none yet)
```

Each component has its own dependency tree. The `harness/` is stdlib-only, while `platform/` depends on `harness/` and `shared/`.

---

## Data Flow

### CLI Workflow
```
User Input → Task Creation → Worktree Setup → Planning → Execution
    → Testing → Review → Refactoring → Commit → PR Creation
```

Each step:
1. Emits `agent_started` event
2. Performs work (Claude AI, git operations, etc.)
3. Saves checkpoint (git commit)
4. Emits `agent_completed` event
5. Hands off context to next step (compressed)

### Desktop Integration Flow
```
User clicks "Boatman Mode" → Creates session → Spawns CLI subprocess
    → Parses stdout events → Emits Wails events → React updates UI
```

### Platform Data Flow
```
CLI starts run → TryConnect to Platform (3s timeout)
    → If connected: fetch policy, fetch memory, create run record
    → Execute pipeline with PolicyGuard, CostHooks, ObserverAdapter
    → Each step: record cost, check budget, publish events
    → On complete: update run, learn from results
    → Dashboard shows real-time progress via SSE
```

### Firefighter Flow
```
User clicks "Investigate" → Claude uses MCP tools → Queries Linear/Bugsnag/Datadog
    → Analyzes git history → Generates report → Optionally creates fix PR
```
